{
  "language": "Solidity",
  "sources": {
    "src/ERC721SBT/ERC721SBT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IERC165} from \"../interfaces/IERC165.sol\";\n\ncontract ERC721SBT is IERC721 {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed id\n    );\n\n    event SkillUpdated(\n        address indexed userAddr,\n        string indexed skillName,\n        uint8 indexed level\n    );\n\n    event TokenURISet(uint256 indexed tokenId, string uri);\n    event addedToWhitelist(address indexed userAddr);\n\n    address public admin;\n\n    uint8 public constant MAX_LEVEL = 2;\n\n    mapping(address => mapping(bytes32 => uint8)) public _skillLevels;\n\n    mapping(address => bool) internal _whiteList;\n\n    mapping(uint256 => string) internal _tokenUri;\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint8) internal _balanceOf;\n\n    constructor(address _admin) {\n        require(_admin != address(0), \"verifier = zero address\");\n        admin = _admin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"you are not admin\");\n        _;\n    }\n\n    modifier onlyWhiteListed() {\n        require(_whiteList[msg.sender], \"not whitelisted\");\n        _;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external pure returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n\n    function ownerOf(uint256 id) external view returns (address owner) {\n        owner = _ownerOf[id];\n        require(owner != address(0), \"token doesn't exist\");\n    }\n\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"owner = zero address\");\n        return _balanceOf[owner];\n    }\n\n    function isWhiteListed(address userAddr) external view returns (bool) {\n        return _whiteList[userAddr];\n    }\n\n    function addToWhitelist(address userAddr) external onlyAdmin {\n        _whiteList[userAddr] = true;\n        emit addedToWhitelist(userAddr);\n    }\n\n    function skillLevels(\n        string memory skillName\n    ) external view returns (uint8) {\n        require(_balanceOf[msg.sender] > 0, \"mint SBT first\");\n        bytes32 skillKey = keccak256(abi.encodePacked(skillName));\n        return _skillLevels[msg.sender][skillKey];\n    }\n\n    function _updateSkill(string memory skillName) internal onlyWhiteListed {\n        require(_balanceOf[msg.sender] > 0, \"mint SBT first\");\n        bytes32 skillKey = keccak256(abi.encodePacked(skillName));\n        uint8 currentLevel = _skillLevels[msg.sender][skillKey];\n        require(currentLevel < MAX_LEVEL, \"Max level reached\");\n\n        _skillLevels[msg.sender][skillKey] = currentLevel + 1;\n        emit SkillUpdated(msg.sender, skillName, currentLevel + 1);\n    }\n\n    function _mint(address to, uint256 id) internal {\n        require(to != address(0), \"mint to zero address\");\n        require(_balanceOf[to] == 0, \"user already has an SBT\");\n        require(_ownerOf[id] == address(0), \"token already minted\");\n\n        _balanceOf[to] = 1;\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n\n    function _setTokenUri(uint256 id, string memory uri) internal {\n        _tokenUri[id] = uri;\n        emit TokenURISet(id, uri);\n    }\n}\n"
    },
    "src/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\nimport {IERC165} from \"./IERC165.sol\";\n\ninterface IERC721 is IERC165 {\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    // function safeTransferFrom(address from, address to, uint256 tokenId)\n    //     external;\n    // function safeTransferFrom(so where it storing all the user there is no array can it be stored only in map\n    //     address from,\n    //     address to,\n    //     uint256 tokenId,\n    //     bytes calldata data\n    // ) external;\n    // function transferFrom(address from, address to, uint256 tokenId) external;\n    // function approve(address to, uint256 tokenId) external;\n    // function getApproved(uint256 tokenId)\n    //     external\n    //     view\n    //     returns (address operator);\n    // function setApprovalForAll(address operator, bool _approved) external;\n    // function isApprovedForAll(address owner, address operator)\n    //     external\n    //     view\n    //     returns (bool);\n}"
    },
    "src/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        returns (bool);\n}"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode.object",
          "evm.bytecode.sourceMap",
          "evm.bytecode.linkReferences",
          "evm.deployedBytecode.object",
          "evm.deployedBytecode.sourceMap",
          "evm.deployedBytecode.linkReferences",
          "evm.deployedBytecode.immutableReferences",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "evmVersion": "prague",
    "viaIR": false,
    "libraries": {}
  }
}
